package se.got;


import java.io.File;
import java.io.FileFilter;
import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.function.BinaryOperator;

import se.got.ltl.LTLConjunction;
import se.got.ltl.LTLFormula;

public class Templates {
	
	public static final String PatternsTemplate = 
	  " \n"
	+ " \n"		
	+"import se.got.constraints.*; \n"
	+"import se.got.engine.*; \n"
	+"import se.got.gui.*; \n"
    +"import se.got.ltl.*; \n"
    +"import se.got.ltl.atoms.*; \n"
    +"import se.got.ltl.visitors.*; \n"
    +"import se.got.mappings.*; \n"
    +"import se.got.sel.*; \n"
    +"import se.got.sel.patterns.*; \n"
    +"import se.got.sel.patterns.occurrence.*; \n"
    +"import se.got.sel.patterns.order.*; \n"
    +"import se.got.sel.scopes.*; \n"
    +"import java.util.Arrays; \n"
	+"import java.util.List; \n"
	+"import java.util.function.BinaryOperator; \n"
	+"import java.io.File;  \n"
	+"import java.io.FileFilter;  \n"
	+"import java.io.FileOutputStream;  \n"
	+"import java.io.ObjectOutputStream;  \n"
	+"import java.lang.reflect.InvocationTargetException;  \n"
	+"import java.lang.reflect.Method;  \n"
	+"import java.net.URL;  \n"
	+"import java.net.URLClassLoader;  \n"
	+ " \n"
	+ " \n"
	+"public class {{patternName}} implements java.io.Serializable { \n" 
		+ "	public static String DirPath = \"\"; \n"
		+ "	@Override \n" 
		+ "	public String toString() { \n"
		+ "		return \"{{patternName}}\"; \n"
		+ "	} \n" 
		+ "	\n"
		+ "	public static void main(String[] args){ \n"
		+ "		String homeDir = System.getProperty(\"user.home\"); \n"
		+ "		String appDir = homeDir + \"/Co4robots\"; \n"
		+ "		File appFolder = new File(appDir); \n"
		+ "		if(appFolder.isDirectory() && appFolder.exists()){ \n"
		+ "			//do nothing \n"
		+ "		}else{ \n"
		+ "			try { \n"
		+ "				boolean foo  = appFolder.mkdir(); \n"
		+ "				System.out.println(foo); \n"
		+ "			} catch (Exception e) { \n"
		+ "				// TODO Auto-generated catch block \n"
		+ "				e.printStackTrace(); \n"
		+ "				System.out.println(\"New creation failed\"); \n"
		+ "			} \n"
		+ "		} \n"
		+ "		{{patternName}}.DirPath = appDir; \n"
		+ "		{{patternName}} pattern = new {{patternName}}(); \n"
		+ " 	\n"
		+ "		if(args != null && args.length > 0 && args[0].equalsIgnoreCase(\"mission\")){ \n"
		+ "			String[] missionArgs = Arrays.copyOfRange(args, 1, args.length);\n"
		+ "			LTLFormula formula = pattern.getMission(missionArgs); \n"
		+ "			String str = formula.accept(new LTLFormulaToStringVisitor()); \n"
		+ "			System.out.println(str); \n"
		+ "		} \n"
		+ " 	\n"
		+ "		if(args != null && args.length > 0 && args[0].equalsIgnoreCase(\"description\")){ \n"
		+ "			String str = pattern.getDescription(); \n"
		+ "			System.out.println(str); \n"
		+ "		} \n"
		+ " 	\n"
		+ "		if(args != null && args.length > 0 && args[0].equalsIgnoreCase(\"variations\")){ \n"
		+ "			String str = pattern.getVariations(); \n"
		+ "			System.out.println(str); \n"
		+ "		} \n"
		+ " 	\n"
		+ "		if(args != null && args.length > 0 && args[0].equalsIgnoreCase(\"examples\")){ \n"
		+ "			String str = pattern.getExamples(); \n"
		+ "			System.out.println(str); \n"
		+ "		} \n"
		+ " 	\n"
		+ "		if(args != null && args.length > 0 && args[0].equalsIgnoreCase(\"relationships\")){ \n"
		+ "			String str = pattern.getRelationships(); \n"
		+ "			System.out.println(str); \n"
		+ "		} \n"
		+ " 	\n"
		+ "		if(args != null && args.length > 0 && args[0].equalsIgnoreCase(\"occurrences\")){ \n"
		+ "			String str = pattern.getOccurrences(); \n"
		+ "			System.out.println(str); \n"
		+ "		} \n"
		+ "	} \n"
		+ "	\n"
		+ "	public LTLFormula getMission(String[] args) { \n"
		+ "		//{{formulaBody}}  \n"
		+ "		return (LTLFormula) new LTLEventually(new LTLIPropositionalAtom(\"input\")); \n" 
		+ "	} \n"
		+ "	\n"
		+ "	public LTLFormula getMission(LTLFormula f1, LTLFormula f2) { \n"
		+ "	\n"
		+ "		return  LTLFormula.TRUE; \n" 
		+ "	} \n"
		+ " \n"
		+ "	//@Override \n" 
		+ "	public String getDescription() { \n" 
		+ "		return \"{{patternDescription}}\"; \n" 
		+ "	} \n"
		+ " \n"
		+ "	//@Override \n"
		+ "	public String getVariations() { \n"
		+ "		return \"{{patternVariations}}\"; \n" 
		+ "	} \n"
		+ " \n"
		+ "	//@Override \n"
		+ "	public String getExamples() { \n" 
		+ "		return \"{{patternExamples}}\"; \n" 
		+ "	} \n"
		+ " \n"
		+ "	//@Override \n"
		+ "	public String getRelationships() { \n"
		+ "		return \"{{patternRelationships}}\"; \n" 
		+ "	} \n"
		+ " \n"
		+ "	//@Override \n"
		+ "	public String getOccurrences() { \n"
		+ "		return \"{{patternOccurrences}}\"; \n" 
		+ "	} \n"
		+ " \n"
		+ "	public static final BinaryOperator<LTLFormula> conjunctionOperator = (left, right) -> { \n"
		+ " \n"
		+ "		if (left.equals(LTLFormula.TRUE)) { \n"
		+ "			return right; \n"
		+ "		} \n"
		+ " \n"
		+ "		if (right.equals(LTLFormula.TRUE)) { \n"
		+ "			return left; \n"
		+ "		} \n"
		+ "		return new LTLConjunction(left, right); \n"
		+ "	}; \n"
		+ " \n"
		+ "	public LTLFormula extractFormulaFrom(String loadedPatternSignature){  \n"
		+ "		String patternSignature = loadedPatternSignature.replace(\"~\", \"\");  \n"
		+ "		//System.out.println(\"pattern2see:\" + patternSignature); \n"
		+ "		String []parts = patternSignature.split(\"\\\\(\");  \n"
		+ "		String patternName = parts[0];   \n"
		+ "		String argsStr = parts[1].replace(\")\",\"\");  \n"
		+ "		String []args = argsStr.split(\",\");  \n"
		+ " \n"
		+ "		//look for the location of this pattern  \n"
		+ "		String patterCategory = \"\";  \n"
		+ "		File directory = new File({{patternName}}.DirPath);	  \n"	
		+ "		FileFilter directoryFileFilter = new FileFilter() {  \n"
		+ "			public boolean accept(File file) {  \n"
		+ "				return file.isDirectory() && !file.getName().equals(\"lib\");  \n"
		+ "			}  \n"
		+ "		};  \n"
		+ "		String categoryName = \"\";  \n"
		+ "		File[] directoryListAsFile = directory.listFiles(directoryFileFilter);  \n"
		+ "		for (File directoryAsFile : directoryListAsFile) {  \n"
		+ "			String catNameTemp = directoryAsFile.getName();  \n"
		+ "			//need to search through this directory  \n"
		+ "			File subDir = new File({{patternName}}.DirPath + \"/\" + catNameTemp, patternName);  \n"
		+ "			if(subDir.exists() && subDir.isDirectory()){  \n"
		+ "				categoryName = catNameTemp;  \n"
		+ "				break;  \n"
		+ "			}  \n"
		+ "		}  \n"
		+ " \n"	
		+ " \n"	
		+ "		String path = {{patternName}}.DirPath + \"/\" + categoryName + \"/\" + patternName;  \n"
		+ " \n"
		+ "		try {  \n"
		+ "			URL[] classes = {new File(path).toURI().toURL()};  \n"
		+ "			URLClassLoader child = new URLClassLoader (classes, this.getClass().getClassLoader());  \n"
		+ " \n"
		+ "			Class classToLoad = Class.forName(patternName, true, child);  \n"
		+ "			Method method = classToLoad.getDeclaredMethod (\"getMission\", String[].class);  \n"
		+ "			Object instance = classToLoad.newInstance();  \n"	        
		+ "			Object result = method.invoke(instance, (Object)(args));  \n"
		+ "			LTLFormula fmx = (LTLFormula)result;  \n"
		+ "			//System.out.println(\"loaded formula is: \" + fmx.toString());  \n"
		+ "			return fmx;  \n"
		+ "		} catch (ClassNotFoundException e) { \n"
		+ "			e.printStackTrace(); \n"
		+ "		} catch (SecurityException e) { \n"
		+ "			e.printStackTrace(); \n"
		+ "		} catch (NoSuchMethodException e) { \n"
		+ "			e.printStackTrace(); \n"
		+ "		} catch (InstantiationException e) { \n"
		+ "			e.printStackTrace(); \n"
		+ "		} catch (IllegalAccessException e) { \n"
		+ "			e.printStackTrace(); \n"
		+ "		} catch (IllegalArgumentException e) { \n"
		+ "			e.printStackTrace(); \n"
		+ "		} catch (InvocationTargetException e) { \n"
		+ "			e.printStackTrace(); \n"
		+ "		} catch (Exception e) { \n"
		+ "			e.printStackTrace(); \n"
		+ "		} \n"
		+ "		return LTLFormula.TRUE; \n"
		+ "	} \n"
	+ "} \n";

	public static ArrayList<String> findFoldersInDirectory(String directoryPath) {
	    File directory = new File(directoryPath);
		
	    FileFilter directoryFileFilter = new FileFilter() {
	        public boolean accept(File file) {
	            return file.isDirectory();
	        }
	    };
			
	    File[] directoryListAsFile = directory.listFiles(directoryFileFilter);
	    ArrayList<String> foldersInDirectory = new ArrayList<String>(directoryListAsFile.length);
	    for (File directoryAsFile : directoryListAsFile) {
	    	String foo = directoryAsFile.getName();
	    	if(!foo.equals("lib")){
	    		System.out.println("found:>" + foo);
	    		foldersInDirectory.add("~" + foo);
	    	}
	    }

	    return foldersInDirectory;
	}
}
